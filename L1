type variable = string

type operator = Sum | Diff | Mult | Div | Eq | Leq | Not | And | Or 

type tipo  = TyInt | TyBool | TyFn of tipo * tipo | TyList of tipo 

type expr = Num of int
          | Bool of bool
          | Bop of operator * expr * expr
          | If of expr * expr * expr
          | Var of variable
          | App of expr * expr
          | Lam of variable * tipo * expr
          | Let of variable * tipo * expr * expr
          | Lrec of variable * tipo * tipo * variable * tipo * expr * expr
          | Nil                  
          | Cons of expr * expr
          | IsEmpty of expr
          | First of expr
          | Rest of expr
          | Raise
          | TryWith of expr * expr

type value = Vnum of int
           | Vbool of bool
           | Vclos of variable * expr * env
           | Vrclos of variable * variable * expr * env
           | Vnil                    
           | Vcons of value * value
           | Raise    
and
     env = (variable * value) list

(*Não sei porque tem isso, mas tinha nos outros dois *)
and
     tenv = (variable * tipo) list
     
     

          
(* Procura por uma variável no ambiente. Usada no C-ID *)
let rec search variable env : value = match env with
  | [] -> raise Not_found
  (* tl pega o resto da lista *)
  | (name, v)::tl ->
    if (name == variable)      (* Found the variable in the head *)
    then v                     (* Returns variable value *)
else search variable tl ;; (* Look for it in the tale *)     
     
     
     
     
     
     
     

(* AVALIADOR BIG STEP *)
(* context do tipo env, e do tipo expr *)
let rec eval (context : env) (e : expr) = ( match e with
    
    Num(n) -> Vnum(n)
    | Bool(b) -> Vbool(b)
    
    (*  op ∈ {+, −, ∗, div, ==, and, or, not}  *)
    | Bop(op, e1, e2) -> (
        let exp1 = eval context e1 in
        let exp2 = eval context e2 in (
            match(op, exp1, exp2) with
              (Sum, Vnum n1, Vnum n2) -> Vnum(n1 + n2)
            | (Diff, Vnum n1, Vnum n2) -> Vnum(n1 - n2)
            | (Mult, Vnum n1, Vnum n2) -> Vnum(n1 * n2)
            | (Div, Vnum n1, Vnum n2) -> if n2 != 0 then Vnum(n1 / n2) else Raise
            | (Eq, Vnum n1, Vnum n2) -> Vbool(n1 == n2)
            | (And, Vbool b1, Vbool b2) -> Vbool(b1 && b2)
            | (Or, Vbool b1, Vbool b2) -> Vbool(b1 || b2)
            | (_, Raise, _) -> Raise
            | (_, _, Raise) -> Raise
            | _ -> failwith "binary_op_error"
        )
    )
    
    (* if *)
    
    
    | If(e1, e2, e3) when ((eval context e1) = Vbool(true)) -> eval context e2
	| If(e1, e2, e3) when ((eval context e1) = Vbool(false)) -> eval context e3
    
    
    (*
        | If(e1, e2, e3) -> (
            let exp1 = eval context e1 in (
                match exp1 with
                  (Vbool true) -> eval context e2
                | (Vbool false) -> eval context e3
                | Raise -> Raise
                | _ -> failwith "if_error"
            )
        )
    *)
    
    (* C-NIL *)
    | Nil -> Vnil
    
    
    (* C-CONS *)
    | Cons(e1, e2) -> (
        let exp1 = eval context e1 in
        let exp2 = eval context e2 in (
            match (exp1, exp2) with
            | (Raise,_) -> Raise
            | (_,Raise) -> Raise
            | _ -> Vcons(exp1, exp2)
        )
    )
    
    
    (* is empty *)
    | IsEmpty(e) -> (
        let e1 = eval context e in (
            match e1 with
            | Vnil -> (Vbool true)
            | Vcons(v1,v2) -> (Vbool false)
            | Raise -> Raise
            | _ -> failwith "is_empty_error"
        )
    )
    
    (* first  *)
    | First(e) -> (
        let e1 = eval context e in (
            match e1 with
            | Vcons(v1,v2) -> v1
            | Vnil -> Raise
            | Raise -> Raise
            | _ -> failwith "first_error"
        )
    )
    
    
    (* rest *)
    | Rest(e) -> (
        let e1 = eval context e in (
            match e1 with
            | Vcons(v1,v2) -> v2
            | Vnil -> Raise
            | Raise -> Raise
            | _ -> failwith "rest_error"
        )
    )
    
    (* raise *)
    | Raise -> Raise
    
    
    (* TryWith *)
    | TryWith(e1,e2) -> (
        let exp1 = eval context e1 in (
            match exp1 with
            | Raise -> eval context e2
            | _ -> exp1
        )
    )
    
        
    (C-Id)
    | Var(v) -> search v context
    
    (* Function to update environment *)
    let update variable v context : env = match context with
    | [] -> [(variable, v)]
    | hd::tl -> List.append [(variable, v)] context ;;
    
    (C-App)
    | App(e1, e2) ->
        let exp1 = eval context e1 in
        let exp2 = eval context e2 in
        (match exp1, exp2 with
            Vclos(variable, e, envA), value -> eval (update variable value envA) e
            | Vrclos(f, x, e, envA), value -> eval (update f (Vrclos(f, x, e, envA)) (update x value envA)) e
            | _ -> raise InvalidEval
        )




)
